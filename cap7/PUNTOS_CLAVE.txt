================================================================================
    CAPÃTULO 7: PROGRAMACIÃ“N ORIENTADA A OBJETOS (POO) - PUNTOS CLAVE
================================================================================

ğŸ“˜ TEMA PRINCIPAL: IntroducciÃ³n a la ProgramaciÃ³n Orientada a Objetos en C++

================================================================================
ğŸ¯ CONCEPTOS FUNDAMENTALES
================================================================================

1. PARADIGMA DE POO
   âœ“ Cambio de enfoque: de funciones a objetos
   âœ“ Los datos y las funciones se agrupan en una sola entidad (clase)
   âœ“ Mayor organizaciÃ³n y reutilizaciÃ³n de cÃ³digo
   âœ“ Modela mejor la realidad (objetos del mundo real)

2. CLASE vs ESTRUCTURA
   âœ“ Struct: miembros pÃºblicos por defecto
   âœ“ Class: miembros privados por defecto
   âœ“ Ambos pueden tener mÃ©todos y datos
   âœ“ Clase permite mejor encapsulamiento

3. OBJETO
   âœ“ Instancia concreta de una clase
   âœ“ Ocupa memoria y tiene valores especÃ­ficos
   âœ“ Cada objeto tiene su propio estado
   âœ“ Se declara como: NombreClase objeto;

================================================================================
ğŸ”’ ENCAPSULAMIENTO
================================================================================

1. MODIFICADORES DE ACCESO
   
   PRIVATE:
   âœ“ Solo accesible dentro de la clase
   âœ“ Protege los datos de modificaciones externas
   âœ“ Es el nivel por defecto en class
   
   PUBLIC:
   âœ“ Accesible desde cualquier parte del programa
   âœ“ Se usa para mÃ©todos de interfaz
   âœ“ Permite la interacciÃ³n con el objeto
   
   PROTECTED:
   âœ“ Accesible en la clase y sus derivadas
   âœ“ Ãštil para herencia (Cap. 9)

2. VENTAJAS DEL ENCAPSULAMIENTO
   âœ“ ProtecciÃ³n de datos sensibles
   âœ“ Control sobre cÃ³mo se modifican los datos
   âœ“ ValidaciÃ³n de valores
   âœ“ Facilita el mantenimiento del cÃ³digo

================================================================================
ğŸ”§ MÃ‰TODOS SETTER Y GETTER
================================================================================

1. MÃ‰TODOS SETTER (setXXX)
   âœ“ Permiten modificar atributos privados
   âœ“ Pueden validar datos antes de asignarlos
   âœ“ Formato: void setNombre(tipo valor)
   âœ“ Ejemplo: void setEdad(int e) { if(e>0) edad=e; }

2. MÃ‰TODOS GETTER (getXXX)
   âœ“ Permiten leer atributos privados
   âœ“ No modifican el estado del objeto
   âœ“ Formato: tipo getNombre()
   âœ“ Ejemplo: int getEdad() { return edad; }

3. BUENAS PRÃCTICAS
   âœ“ Validar datos en los setters
   âœ“ Los getters deben ser const cuando sea posible
   âœ“ No exponer referencias a datos privados
   âœ“ Usar nombres descriptivos

================================================================================
ğŸ—ï¸ CONSTRUCTORES
================================================================================

1. Â¿QUÃ‰ ES UN CONSTRUCTOR?
   âœ“ MÃ©todo especial que se ejecuta al crear un objeto
   âœ“ Mismo nombre que la clase
   âœ“ No tiene tipo de retorno (ni void)
   âœ“ Inicializa los atributos del objeto

2. TIPOS DE CONSTRUCTORES

   a) CONSTRUCTOR POR DEFECTO
      âœ“ Sin parÃ¡metros o con parÃ¡metros por defecto
      âœ“ Se genera automÃ¡ticamente si no defines ninguno
      âœ“ Ejemplo: Circulo() { radio = 0; }
   
   b) CONSTRUCTOR CON PARÃMETROS
      âœ“ Recibe valores para inicializar
      âœ“ MÃ¡s flexible y Ãºtil
      âœ“ Ejemplo: Circulo(double r) { radio = r; }
   
   c) CONSTRUCTOR COPIA
      âœ“ Crea un objeto como copia de otro
      âœ“ Ejemplo: Circulo(const Circulo &c) { radio = c.radio; }

3. LISTA DE INICIALIZACIÃ“N
   âœ“ Forma eficiente de inicializar atributos
   âœ“ Sintaxis: Constructor() : atributo(valor) { }
   âœ“ Se ejecuta ANTES del cuerpo del constructor
   âœ“ Ejemplo: Circulo(double r) : radio(r) { }

4. REGLAS IMPORTANTES
   âœ“ Si defines un constructor, el por defecto desaparece
   âœ“ Puedes tener mÃºltiples constructores (sobrecarga)
   âœ“ Se llama automÃ¡ticamente al crear el objeto
   âœ“ No se puede llamar explÃ­citamente despuÃ©s

================================================================================
ğŸ’¥ DESTRUCTORES
================================================================================

1. Â¿QUÃ‰ ES UN DESTRUCTOR?
   âœ“ MÃ©todo especial que se ejecuta al destruir un objeto
   âœ“ Nombre: ~NombreClase()
   âœ“ No tiene parÃ¡metros ni tipo de retorno
   âœ“ Se llama automÃ¡ticamente

2. Â¿CUÃNDO SE USA?
   âœ“ Liberar memoria dinÃ¡mica (delete)
   âœ“ Cerrar archivos abiertos
   âœ“ Liberar recursos (conexiones, sockets, etc.)
   âœ“ Limpiar antes de que el objeto deje de existir

3. CARACTERÃSTICAS
   âœ“ Solo puede haber UNO por clase
   âœ“ No se puede sobrecargar
   âœ“ Se ejecuta al final del scope { }
   âœ“ Ejemplo: ~Circulo() { cout << "Objeto destruido"; }

================================================================================
ğŸ“¦ ÃMBITO Y VIDA DE LOS OBJETOS
================================================================================

1. OBJETOS LOCALES
   âœ“ Declarados dentro de una funciÃ³n o bloque { }
   âœ“ Se crean al entrar al bloque
   âœ“ Se destruyen al salir del bloque
   âœ“ Uso de memoria en el stack

2. OBJETOS GLOBALES
   âœ“ Declarados fuera de cualquier funciÃ³n
   âœ“ Se crean al iniciar el programa
   âœ“ Se destruyen al terminar el programa
   âœ“ Accesibles desde cualquier funciÃ³n

3. OBJETOS DINÃMICOS
   âœ“ Creados con "new"
   âœ“ Deben liberarse con "delete"
   âœ“ Uso de memoria en el heap
   âœ“ Mayor control pero mÃ¡s responsabilidad

================================================================================
ğŸ“‚ SEPARACIÃ“N DE ARCHIVOS
================================================================================

1. ARCHIVO DE CABECERA (.h o .hpp)
   âœ“ Contiene la DECLARACIÃ“N de la clase
   âœ“ Define la estructura y mÃ©todos
   âœ“ Se incluye con #include "nombre.h"
   âœ“ Usa guardas de inclusiÃ³n: #ifndef, #define, #endif

2. ARCHIVO DE IMPLEMENTACIÃ“N (.cpp)
   âœ“ Contiene la DEFINICIÃ“N de los mÃ©todos
   âœ“ Implementa la lÃ³gica de cada mÃ©todo
   âœ“ Usa el operador de alcance ::
   âœ“ Ejemplo: void Clase::metodo() { ... }

3. ARCHIVO PRINCIPAL (main.cpp)
   âœ“ Contiene la funciÃ³n main()
   âœ“ Incluye el archivo de cabecera
   âœ“ Usa las clases definidas
   âœ“ Punto de entrada del programa

4. VENTAJAS DE LA SEPARACIÃ“N
   âœ“ Mejor organizaciÃ³n del cÃ³digo
   âœ“ Facilita la reutilizaciÃ³n
   âœ“ CompilaciÃ³n independiente
   âœ“ Oculta detalles de implementaciÃ³n

================================================================================
ğŸ“ MEJORES PRÃCTICAS
================================================================================

1. DISEÃ‘O DE CLASES
   âœ“ Una clase = una responsabilidad
   âœ“ Atributos privados, mÃ©todos pÃºblicos
   âœ“ Usar nombres descriptivos
   âœ“ Validar datos en setters

2. CONSTRUCTORES
   âœ“ Siempre definir al menos el constructor por defecto
   âœ“ Inicializar TODOS los atributos
   âœ“ Usar lista de inicializaciÃ³n cuando sea posible
   âœ“ Validar parÃ¡metros recibidos

3. DESTRUCTORES
   âœ“ Liberar TODA la memoria dinÃ¡mica
   âœ“ Cerrar TODOS los recursos abiertos
   âœ“ No lanzar excepciones desde el destructor
   âœ“ Mantenerlo simple y rÃ¡pido

4. MÃ‰TODOS
   âœ“ MÃ©todos que no modifican: marcarlos como const
   âœ“ Usar referencias para parÃ¡metros grandes
   âœ“ Evitar efectos secundarios inesperados
   âœ“ Documentar con comentarios claros

================================================================================
âŒ ERRORES COMUNES
================================================================================

1. Olvidar inicializar atributos en el constructor
2. No liberar memoria dinÃ¡mica en el destructor
3. Hacer pÃºblicos todos los atributos (rompe encapsulamiento)
4. No validar datos en los setters
5. Olvidar las guardas de inclusiÃ³n en archivos .h
6. Confundir declaraciÃ³n (en .h) con definiciÃ³n (en .cpp)
7. No usar const en getters
8. Crear objetos dinÃ¡micos y olvidar hacer delete

================================================================================
ğŸ’¡ EJEMPLOS DE ARCHIVOS EN ESTE CAPÃTULO
================================================================================

01-03: Persona (struct â†’ class â†’ Ã¡mbito)
04-07: CÃ­rculo (setget â†’ bÃ¡sico â†’ constructores â†’ completo)
08-10: Alumno (struct â†’ gestiÃ³n â†’ completo)
11-13: Time (proyecto multi-archivo: .h + .cpp + main)
14-18: Ejercicios (RectÃ¡ngulo, TriÃ¡ngulo, Punto3D, Complejo, Calculadora)

================================================================================
ğŸ”— CONCEPTOS QUE SE VERÃN DESPUÃ‰S
================================================================================

CapÃ­tulo 8: Sobrecarga de Operadores
CapÃ­tulo 9: Herencia y Polimorfismo
CapÃ­tulo 10: Plantillas y GenÃ©ricos
CapÃ­tulo 11: Manejo de Excepciones

================================================================================
ğŸ“ RESUMEN EJECUTIVO
================================================================================

âœ“ La POO organiza el cÃ³digo en objetos (datos + mÃ©todos)
âœ“ El encapsulamiento protege los datos con private/public
âœ“ Los constructores inicializan objetos automÃ¡ticamente
âœ“ Los destructores limpian recursos antes de destruir el objeto
âœ“ Separar cÃ³digo en .h/.cpp mejora la organizaciÃ³n
âœ“ Setters/Getters controlan el acceso a atributos privados

================================================================================
FIN DEL DOCUMENTO
================================================================================
