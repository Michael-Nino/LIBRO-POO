================================================================================
   CAP√çTULO 8: SOBRECARGA DE OPERADORES - PUNTOS CLAVE
================================================================================

üìò TEMA PRINCIPAL: Sobrecarga de Operadores en C++

================================================================================
üéØ CONCEPTOS FUNDAMENTALES
================================================================================

1. ¬øQU√â ES LA SOBRECARGA DE OPERADORES?
   ‚úì Permite usar operadores (+, -, *, /, ==, etc.) con objetos de clases
   ‚úì Da significado a los operadores para tipos definidos por el usuario
   ‚úì Hace el c√≥digo m√°s natural e intuitivo
   ‚úì Ejemplo: complejo1 + complejo2 en lugar de complejo1.sumar(complejo2)

2. VENTAJAS
   ‚úì C√≥digo m√°s legible y expresivo
   ‚úì Sintaxis natural similar a tipos primitivos
   ‚úì Facilita operaciones matem√°ticas con objetos
   ‚úì Hace que las clases se comporten como tipos built-in

3. LIMITACIONES
   ‚úì No se pueden crear nuevos operadores
   ‚úì No se puede cambiar la precedencia de operadores
   ‚úì No se puede cambiar el n√∫mero de operandos
   ‚úì Algunos operadores no se pueden sobrecargar (::, ., .*, ?:, sizeof)

================================================================================
üîß SINTAXIS B√ÅSICA
================================================================================

1. SOBRECARGA COMO M√âTODO MIEMBRO

   Formato:
   TipoRetorno operator@(parametros)
   
   Ejemplo:
   Complejo operator+(const Complejo &c)
   {
       Complejo temp;
       temp.real = real + c.real;
       temp.imag = imag + c.imag;
       return temp;
   }
   
   Uso: c3 = c1 + c2;  // Equivale a: c3 = c1.operator+(c2);

2. SOBRECARGA COMO FUNCI√ìN FRIEND

   Formato:
   friend TipoRetorno operator@(parametros)
   
   Ejemplo:
   friend Complejo operator+(const Complejo &a, const Complejo &b)
   {
       return Complejo(a.real + b.real, a.imag + b.imag);
   }
   
   Ventaja: Permite conversiones impl√≠citas en ambos operandos

================================================================================
‚ûï OPERADORES ARITM√âTICOS
================================================================================

1. OPERADORES BINARIOS: +, -, *, /
   
   Como MIEMBRO:
   ‚úì Sintaxis: Tipo operator+(const Tipo &otro)
   ‚úì El primer operando es el objeto actual (this)
   ‚úì El segundo operando es el par√°metro
   
   Como FRIEND:
   ‚úì Sintaxis: friend Tipo operator+(const Tipo &a, const Tipo &b)
   ‚úì Ambos operandos son par√°metros
   ‚úì Mejor para conversiones impl√≠citas

2. OPERADORES UNARIOS: +, -, ++, --
   
   PREFIJO (++x):
   ‚úì Sintaxis: Tipo& operator++()
   ‚úì Incrementa y devuelve referencia
   ‚úì Retorna: *this
   
   POSTFIJO (x++):
   ‚úì Sintaxis: Tipo operator++(int)
   ‚úì Guarda valor, incrementa, devuelve valor guardado
   ‚úì El par√°metro 'int' es solo para diferenciar
   ‚úì Menos eficiente que el prefijo

================================================================================
üîç OPERADORES DE COMPARACI√ìN
================================================================================

1. IGUALDAD Y DESIGUALDAD: ==, !=
   
   Ejemplo:
   bool operator==(const Tipo &otro) const
   {
       return (dato1 == otro.dato1 && dato2 == otro.dato2);
   }
   
   bool operator!=(const Tipo &otro) const
   {
       return !(*this == otro);  // Reutiliza operator==
   }

2. RELACIONALES: <, >, <=, >=
   
   Ejemplo:
   bool operator<(const Tipo &otro) const
   {
       return (valor < otro.valor);
   }
   
   Consejo: Implementar < y ==, los dem√°s se derivan

================================================================================
üîÑ OPERADORES DE ASIGNACI√ìN
================================================================================

1. OPERADOR DE ASIGNACI√ìN SIMPLE: =
   
   Formato:
   Tipo& operator=(const Tipo &otro)
   {
       if(this != &otro)  // Evitar auto-asignaci√≥n
       {
           // Copiar datos
           dato = otro.dato;
       }
       return *this;  // Permite: a = b = c
   }
   
   IMPORTANTE:
   ‚úì Verificar auto-asignaci√≥n (x = x)
   ‚úì Devolver *this para permitir asignaciones en cadena
   ‚úì Si hay memoria din√°mica, liberar la antigua primero

2. OPERADORES DE ASIGNACI√ìN COMPUESTA: +=, -=, *=, /=
   
   Ejemplo:
   Tipo& operator+=(const Tipo &otro)
   {
       dato += otro.dato;
       return *this;
   }
   
   Ventaja: M√°s eficiente que: x = x + y

================================================================================
üì•üì§ OPERADORES DE ENTRADA/SALIDA
================================================================================

1. OPERADOR DE SALIDA: <<
   
   SIEMPRE como funci√≥n FRIEND:
   
   friend ostream& operator<<(ostream &os, const Tipo &obj)
   {
       os << "Dato: " << obj.dato;
       return os;  // Permite: cout << obj1 << obj2
   }
   
   Uso: cout << miObjeto << endl;

2. OPERADOR DE ENTRADA: >>
   
   friend istream& operator>>(istream &is, Tipo &obj)
   {
       is >> obj.dato;
       return is;  // Permite: cin >> obj1 >> obj2
   }
   
   Uso: cin >> miObjeto;
   
   IMPORTANTE:
   ‚úì DEBE ser funci√≥n friend (no puede ser miembro)
   ‚úì El objeto NO debe ser const en operator>>
   ‚úì Devolver la referencia al stream para encadenar

================================================================================
üìë OPERADOR DE √çNDICE: []
================================================================================

1. ACCESO POR √çNDICE

   Para lectura:
   Tipo operator[](int indice) const
   {
       return datos[indice];
   }
   
   Para escritura:
   Tipo& operator[](int indice)
   {
       return datos[indice];  // Devuelve referencia
   }
   
   Uso: obj[0] = 10;  // Escritura
        x = obj[0];   // Lectura

2. VALIDACI√ìN
   ‚úì Verificar l√≠mites del arreglo
   ‚úì Lanzar excepci√≥n si √≠ndice inv√°lido
   ‚úì Considerar usar at() en lugar de []

================================================================================
üí° FUNCIONES FRIEND
================================================================================

1. ¬øQU√â ES UNA FUNCI√ìN FRIEND?
   ‚úì No es miembro de la clase
   ‚úì Tiene acceso a miembros privados
   ‚úì Se declara dentro de la clase con 'friend'
   ‚úì Se define fuera como funci√≥n normal (sin ::)

2. CU√ÅNDO USAR FRIEND
   ‚úì Operadores de entrada/salida (<<, >>)
   ‚úì Cuando se necesita simetr√≠a en operadores binarios
   ‚úì Para permitir conversiones impl√≠citas en ambos operandos
   ‚úì Cuando el primer operando no es un objeto de la clase

3. VENTAJAS Y DESVENTAJAS
   
   Ventajas:
   ‚úì Flexibilidad en la sobrecarga
   ‚úì Permite notaci√≥n natural
   ‚úì Conversiones autom√°ticas en ambos lados
   
   Desventajas:
   ‚úì Rompe el encapsulamiento (tiene acceso a private)
   ‚úì No es miembro, no tiene this
   ‚úì Debe redeclararse en clases derivadas

================================================================================
üìä EJEMPLOS PR√ÅCTICOS EN ESTE CAP√çTULO
================================================================================

1. CLASE COMPLEJO (Archivos 01-05, 09-10)
   ‚úì Operadores aritm√©ticos: +, -, *, /
   ‚úì Operadores de entrada/salida: <<, >>
   ‚úì Comparaci√≥n de diferentes enfoques (miembro vs friend)

2. CLASE ENTERO (Archivos 06)
   ‚úì Operadores de incremento/decremento: ++, --
   ‚úì Prefijo y postfijo
   ‚úì Operadores relacionales: <, >, ==, !=

3. CLASE RACIONAL (Archivos 07)
   ‚úì Representaci√≥n de n√∫meros racionales (a/b)
   ‚úì Operadores aritm√©ticos con simplificaci√≥n
   ‚úì Conversi√≥n a formato de salida adecuado

4. CLASE ARREGLO (Archivos 08)
   ‚úì Operador de √≠ndice: []
   ‚úì Operador de asignaci√≥n: =
   ‚úì Operadores de entrada/salida

5. EJERCICIOS PROPUESTOS
   ‚úì Ascensor: Operadores ++ y -- para subir/bajar pisos
   ‚úì Polinomio: Operaciones con polinomios
   ‚úì Matriz: Operaciones matriciales
   ‚úì Caja: Comparaci√≥n de vol√∫menes

================================================================================
‚úÖ MEJORES PR√ÅCTICAS
================================================================================

1. DISE√ëO
   ‚úì Solo sobrecargar operadores con significado intuitivo
   ‚úì Mantener la sem√°ntica natural del operador
   ‚úì Si sobrecargas ==, tambi√©n sobrecarga !=
   ‚úì Si sobrecargas <, considera sobrecargar >, <=, >=

2. EFICIENCIA
   ‚úì Usar referencias const para par√°metros grandes
   ‚úì Devolver por valor cuando sea necesario (evitar referencias colgantes)
   ‚úì Preferir operadores compuestos (+=) sobre (+ seguido de =)
   ‚úì Usar lista de inicializaci√≥n en constructores

3. CONSISTENCIA
   ‚úì Operadores relacionados deben ser consistentes
   ‚úì a + b debe dar el mismo resultado que b + a (si es conmutativo)
   ‚úì (a + b) + c debe ser igual que a + (b + c) (asociatividad)

4. CONST CORRECTNESS
   ‚úì Marcar m√©todos que no modifican como const
   ‚úì Par√°metros que no cambian deben ser const
   ‚úì Operadores de comparaci√≥n casi siempre son const

================================================================================
‚ùå ERRORES COMUNES
================================================================================

1. No devolver *this en operadores de asignaci√≥n
2. Olvidar verificar auto-asignaci√≥n en operator=
3. Usar funci√≥n miembro para << o >> (debe ser friend)
4. No marcar par√°metros como const cuando corresponde
5. Devolver referencia a objeto local temporal
6. No considerar la eficiencia (copias innecesarias)
7. Sobrecargar operadores con comportamiento no intuitivo
8. Olvidar el par√°metro 'int' en operator++(int)

================================================================================
üîó TABLA DE OPERADORES SOBRECARGABLES
================================================================================

PUEDEN sobrecargarse:
‚úì Aritm√©ticos: +, -, *, /, %
‚úì Relacionales: <, >, <=, >=, ==, !=
‚úì L√≥gicos: &&, ||, !
‚úì Incremento/Decremento: ++, --
‚úì Asignaci√≥n: =, +=, -=, *=, /=, %=
‚úì Entrada/Salida: <<, >>
‚úì Acceso: [], ()
‚úì Puntero: *, ->
‚úì Memoria: new, delete
‚úì Bits: &, |, ^, ~, <<, >>

NO pueden sobrecargarse:
‚úó Resoluci√≥n de √°mbito: ::
‚úó Acceso a miembro: .
‚úó Puntero a miembro: .*
‚úó Condicional ternario: ?:
‚úó Tama√±o: sizeof
‚úó Informaci√≥n de tipo: typeid

================================================================================
üìù RESUMEN EJECUTIVO
================================================================================

‚úì La sobrecarga permite usar operadores est√°ndar con objetos personalizados
‚úì Hace el c√≥digo m√°s legible y natural
‚úì Puede implementarse como m√©todo miembro o funci√≥n friend
‚úì Los operadores << y >> DEBEN ser funciones friend
‚úì Siempre mantener la sem√°ntica natural del operador
‚úì Cuidar la eficiencia y evitar copias innecesarias
‚úì Verificar auto-asignaci√≥n en operator=
‚úì Usar const correctamente en par√°metros y m√©todos

================================================================================
FIN DEL DOCUMENTO
================================================================================
